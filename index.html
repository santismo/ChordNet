<!DOCTYPE html>
<html lang="en" data-theme="dark">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>ChordWeb üéπ üï∏Ô∏è</title>
<link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin>
<script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
<style>	
  :root{ --bg:#0f172a; --fg:#e5e7eb; --card:#111827; --border:#374151; --accent:#2563eb; --muted:#94a3b8; }
  :root[data-theme="light"]{ --bg:#f8fafc; --fg:#0f172a; --card:#ffffff; --border:#e5e7eb; --accent:#2563eb; }
  html,body{margin:0;background:var(--bg);color:var(--fg);font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif; overscroll-behavior-y: contain;}
  .wrap{max-width:1200px;margin:0 auto;padding:12px}
  header{display:flex;align-items:center;gap:10px}
  h1{font-size:18px;margin:0 8px 0 0}
  button,select,input[type="number"],input[type="range"],input[type="text"],a.iconbtn{
    border-radius:14px;border:1px solid var(--border);background:var(--card);color:var(--fg);padding:8px 10px;font-size:14px;text-decoration:none}
  .pill{border-radius:999px}
  .accent{background:var(--accent); color:#fff; border-color:transparent}
  .row{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
  .row label{min-width:60px;color:var(--muted);font-size:13px}
  .panel{background:var(--card);border:1px solid var(--border);border-radius:16px;padding:10px;margin-top:10px}
  .cards{display:grid;grid-template-columns:1fr 1fr;gap:10px;margin:12px 0 24px}
  @media (max-width:900px){ .cards{grid-template-columns:1fr} }
  .card{background:var(--card);border:1px solid var(--border);border-radius:16px;padding:10px;display:flex;gap:12px}
  .iconbtn{width:40px;height:40px;display:inline-flex;align-items:center;justify-content:center;border-radius:999px}
  .small{font-size:12px;color:var(--muted)}
  .notice{color:#fca5a5}

  /* Viz */
  .vizhead{display:flex;align-items:center;gap:8px;margin-bottom:6px;flex-wrap:wrap}
  .viztools{display:flex;align-items:center;gap:8px;margin-left:auto;flex-wrap:wrap}
  svg#sun{width:100%;height:860px;cursor:grab;background:radial-gradient(ellipse at 50% 50%, rgba(255,255,255,.04), transparent 55%)}
  svg#sun:active{cursor:grabbing}
  .tooltip{position:fixed;pointer-events:none;background:#111;border:1px solid #333;color:#fff;padding:6px 8px;border-radius:8px;font-size:12px;opacity:0;transition:opacity .08s}
</style>
</head>
<body>
<div class="wrap">
  <header>
    <h1>ChordWeb</h1>
    <button id="themeBtn" class="iconbtn" title="Toggle theme">üåô</button>
    <div style="flex:1"></div>
    <a class="iconbtn" href="https://github.com/santismo/ChordWeb" target="_blank" rel="noopener" title="GitHub">üï∏Ô∏è</a>
    <button id="openSettings" class="pill">‚öôÔ∏è Settings</button>
    <button id="resetAll" class="pill">‚ü≤ Reset</button>
  </header>

  <!-- Controls -->
  <div class="panel">
    <div class="row">
      <label>Count</label><input id="count" type="number" min="1" max="16" value="4"/>
      <label>Vol</label><input id="vol" type="range" min="0" max="100" value="45"/>
      <label>Musicality</label><span class="small">Friendly</span>
      <input id="spicy" type="range" min="0" max="100" value="0" title="Friendly ‚Üê‚Äî‚Äî‚Äî‚Äî‚Üí Spicy"/>
      <span class="small">Scary</span>
      <label title="Avoid duplicate names in one batch"><input id="noRepeat" type="checkbox" checked/> No repeat</label>
      <label title="For huge scenarios, draw compact mini clusters"><input id="mini" type="checkbox" checked/> Mini Webs</label>
    </div>
    <div class="row">
      <label>Root</label><select id="rootSel"><option>All Keys</option></select><button id="rootRnd" class="iconbtn">üé≤</button>
      <label>Base</label><select id="baseSel"><option>All Base Modes</option></select><button id="baseRnd" class="iconbtn">üé≤</button>
      <label>Sub</label><select id="subSel"><option>All Sub Modes</option></select><button id="subRnd" class="iconbtn">üé≤</button>
      <label>Start</label><select id="startSel"><option>(none)</option></select>
    </div>
    <div class="row" style="gap:12px">
      <button id="gen" class="pill accent">üåÄ Generate</button>
      <button id="copy" class="pill">üìã Copy</button>
      <div id="notice" class="notice small"></div>
    </div>
  </div>

  <div id="cards" class="cards"></div>

  <!-- Visual -->
  <div class="panel">
    <div class="vizhead">
      <strong>Web Visual</strong>
      <div id="vizMeta" class="small" style="margin-left:8px"></div>
      <div class="viztools">
        <label>Dot r</label><input id="nodeR" type="range" min="3" max="12" step="1" value="6">
        <label>Gap</label><input id="rowGap" type="range" min="24" max="260" step="1" value="64">
        <label>Mini space</label><input id="miniSpace" type="range" min="0" max="1200" step="1" value="80" title="Distance between mini clusters">
        <label>Mini group by</label>
        <select id="miniGroup" title="How to group mini constellations when All Sub Modes is selected">
          <option value="base" selected>Base</option>
          <option value="sub">Sub (All)</option>
        </select>
        <button id="zoomIn"  class="iconbtn" title="Zoom in">Ôºã</button>
        <button id="zoomOut" class="iconbtn" title="Zoom out">Ôºç</button>
        <button id="zoomReset" class="iconbtn" title="Reset view">‚§æ</button>
        <button id="redraw" class="pill">Rebuild</button>
      </div>
    </div>
    <svg id="sun" viewBox="0 0 1200 860" preserveAspectRatio="xMidYMid meet" aria-label="Constellation">
      <g id="zoomG" transform="translate(0,0) scale(1)">
        <g id="modesG"></g>
        <g id="chartG"></g>
        <g id="selG"></g>
        <g id="pathG"></g>
        <g id="pulseG"></g>
      </g>
    </svg>
    <div class="small"> Hotkeys: G (generate), R (reset), 1‚Äì8 (play).</div>
  </div>
</div>
<div id="tip" class="tooltip"></div>

<!-- Settings -->
<div id="settings" role="dialog" aria-modal="true" style="position:fixed;inset:0;display:none;align-items:center;justify-content:center;background:rgba(0,0,0,.45);z-index:10000">
  <div style="width:min(880px,92vw);background:var(--card);border:1px solid var(--border);border-radius:16px;padding:14px">
    <div style="display:flex;align-items:center;gap:8px">
      <h2 style="margin:0 0 6px 0;font-size:16px">Settings</h2>
      <div style="flex:1"></div>
      <button id="closeSettings" class="iconbtn">‚úñ</button>
    </div>
    <div style="display:grid;grid-template-columns:1fr 1fr;gap:10px">
      <div class="panel">
        <div class="row"><label>Load .xlsx</label><input type="file" id="file" accept=".xlsx,.xls"/></div>
        <div class="row"><label>Data URL</label><input id="dataURL" type="text" placeholder="https://.../data.xlsx" style="min-width:320px;flex:1"/><button id="dataURLLoad">Load</button></div>
        <div class="row small">Tip: <code>?xlsx=https://‚Ä¶/file.xlsx</code> autoloads. If CORS blocks it, use file upload.</div>
      </div>
      <div class="panel">
        <div class="row"><strong>Parse stats</strong></div>
        <div id="parseStats" class="small" style="font-family:ui-monospace,Menlo,Consolas,monospace"></div>
      </div>
    </div>
  </div>
</div>

<script>
/* ===== Helpers ===== */
const normLabel = s => (s||"").replace(/\s+/g,' ').trim();

/* ===== Music helpers ===== */
const noteToSemi = {
  "C":0,"B#":0,"C#":1,"Db":1,"D":2,"D#":3,"Eb":3,"E":4,"Fb":4,"F":5,"E#":5,
  "F#":6,"Gb":6,"G":7,"G#":8,"Ab":8,"A":9,"A#":10,"Bb":10,"B":11,"Cb":11
};
const CANON = {0:'C',1:'C#',2:'D',3:'Eb',4:'E',5:'F',6:'F#',7:'G',8:'Ab',9:'A',10:'Bb',11:'B'};
const MODE_ORDER = ["Ionian","Dorian","Phrygian","Lydian","Mixolydian","Aeolian","Locrian"];
const MODE_STEPS = {
  ionian:[0,2,4,5,7,9,11],
  dorian:[0,2,3,5,7,9,10],
  phrygian:[0,1,3,5,7,8,10],
  lydian:[0,2,4,6,7,9,11],
  mixolydian:[0,2,4,5,7,9,10],
  aeolian:[0,2,3,5,7,8,10],
  locrian:[0,1,3,5,6,8,10],
};

/* === Key ordering helpers (top-level) === */
function keySemitone(K){
  const k = (K || "").trim();
  if (Object.prototype.hasOwnProperty.call(noteToSemi, k)) return noteToSemi[k];
  const t = k.replace(/[^A-G#b]/gi, "");
  return noteToSemi[t] ?? 0;
}
function sortKeysChromatic(arr, start='C'){
  const s = keySemitone(start);
  return arr.slice().sort((a,b)=>{
    const da = (keySemitone(a) - s + 12) % 12;
    const db = (keySemitone(b) - s + 12) % 12;
    return da - db;
  });
}

const rand = n => Math.floor(Math.random()*n);
const romanRe = /^[b‚ô≠]?(?:I|II|III|IV|V|VI|VII)¬∞?$/i;

/* parsing */
function parseLabel(s){
  const parts=(s||"").trim().split(/\s+/);
  if(!parts.length) return null;
  let numeral=""; let rootTokens=parts;
  if(romanRe.test(parts.at(-1)||"")){ numeral=parts.at(-1); rootTokens=parts.slice(0,-1); }
  let root=rootTokens.join("");
  if(root.endsWith("¬∞")) return [root.slice(0,-1),'dim7'];
  if(root.endsWith("m")) return [root.slice(0,-1),'min7'];
  if((numeral||"").toLowerCase()==='v') return [root,'dom7'];
  const q={"i":"maj7","ii":"min7","iii":"min7","iv":"maj7","v":"dom7","vi":"min7","vii":"dim7"}[(numeral||"").toLowerCase()]||"maj7";
  return [root,q];
}
function build7th(root,quality){
  const R=noteToSemi[root.replace("‚ôØ","#").replace("‚ô≠","b")] ?? 0;
  const iv={'maj7':[0,4,7,11],'min7':[0,3,7,10],'dom7':[0,4,7,10],'dim7':[0,3,6,9]}[quality]||[0,4,7,11];
  return [iv.map(i=>R+i), R];
}
function chordPCSet(label){ const p=parseLabel(label); if(!p) return new Set(); const [r,q]=p; const [ns]=build7th(r,q); return new Set(ns.map(n=>((n%12)+12)%12)); }
function jaccard(A,B){ let i=0; for(const x of A){ if(B.has(x)) i++; } const u=A.size+B.size-i; return u? i/u : 0; }

/* ===== Families for a (root, base) in modal order ===== */
function familiesFor(rootKey, base){
  const baseName = (base || "Ionian").replace(/^[A-G](?:#|b)?\s+/, ""); // "C Ionian" -> "Ionian"
  const steps = MODE_STEPS[(baseName || "ionian").toLowerCase()] || MODE_STEPS.ionian;
  const R = noteToSemi[rootKey] ?? 0;
  return steps.map(d => `${CANON[(R + d + 1200) % 12]} ${baseName}`);
}

/* ===== Data model =====
   DB.data[key][base][sub] = [{family: <col D>, degrees: [E..K]}...] */
const DB={keys:[],data:{},stats:{sheets:0,rows:0,rowsUsed:0,chordCells:0},nodeIndex:new Map()};
function modeRank(s){ s=(s||"").toLowerCase(); for(let i=0;i<MODE_ORDER.length;i++){ if(s.includes(MODE_ORDER[i].toLowerCase())) return i; } return 999; }
function sortModesCW(a,b){ const ra=modeRank(a), rb=modeRank(b); if(ra!==rb) return ra-rb; return (a||"").localeCompare(b||""); }
function displaySubLabel(S){
  let parts=(S||"").trim().split(/\s+/);
  if(parts.length && /^[A-G](?:#|b)?$/i.test(parts[0])) parts=parts.slice(1); // strip leading root
  return parts.join(' ');
}
function sortSubsModal(a,b){
  const da=displaySubLabel(a), db=displaySubLabel(b);
  const ra=modeRank((da.split(/\s+/)[0]||"")), rb=modeRank((db.split(/\s+/)[0]||""));
  if(ra!==rb) return ra-rb;
  return da.localeCompare(db);
}
function uniqueSubsForBase(k,b){
  const src = Object.keys((DB.data[k]||{})[b]||{}).sort(sortSubsModal);
  const seen=new Set(), out=[];
  for(const s of src){ const disp=displaySubLabel(s); if(!seen.has(disp)){ seen.add(disp); out.push({value:s, disp}); } }
  return out;
}
function ingestXLSX(wb){
  const data={}; const names=wb.SheetNames||[]; let total=0, used=0, chords=0;
  for(const s of names){
    const ws=wb.Sheets[s]; if(!ws) continue;
    const rows=XLSX.utils.sheet_to_json(ws,{header:1,raw:true,blankrows:false});
    if(!rows||rows.length<2) continue;
    total += (rows.length-1);
    const key=(s||"").trim();
    let lastBase="", lastSub="";
    for(let r=1;r<rows.length;r++){
      const row=rows[r]||[];
      const baseCell=(row[1]!=null?(""+row[1]).trim():""); if(baseCell) lastBase=baseCell;
      const subCell =(row[2]!=null?(""+row[2]).trim():""); if(subCell) lastSub=subCell;
      const famCell =(row[3]!=null?(""+row[3]).trim():"");
      const base=lastBase, sub=lastSub; if(!base||!sub) continue;
      const degrees=[];
      for(let c=4;c<600;c++){ const v=row[c]; if(v==null) continue; const s=(""+v).trim(); if(s) degrees.push(s); }
      if(!degrees.length) continue;
      used++; chords += degrees.length;
      (data[key] ||= {})[base] ||= {};
      (data[key][base][sub] ||= []).push({family:famCell, degrees});
    }
  }
  DB.keys=Object.keys(data).sort();
  DB.data=data; DB.stats={sheets:names.length,rows:total,rowsUsed:used,chordCells:chords};
}

/* ===== UI: selectors ===== */
function updateSelectors(){
  const rootSel=document.getElementById('rootSel');
  rootSel.innerHTML = `<option>All Keys</option>` + DB.keys.map(k=>`<option>${k}</option>`).join("");
  document.getElementById('baseSel').innerHTML=`<option>All Base Modes</option>`;
  document.getElementById('subSel').innerHTML = `<option>All Sub Modes</option>`;
  refreshStartChoices();
}
function onRootChange(){
  const k=val('rootSel');
  const baseSel=document.getElementById('baseSel');
  const subSel=document.getElementById('subSel');
  if(k==="All Keys"){ baseSel.innerHTML=`<option>All Base Modes</option>`; subSel.innerHTML=`<option>All Sub Modes</option>`; }
  else {
    const bases=Object.keys(DB.data[k]||{}).sort(sortModesCW);
    baseSel.innerHTML = `<option>All Base Modes</option>` + bases.map(b=>`<option>${b}</option>`).join("");
    subSel.innerHTML = `<option>All Sub Modes</option>`;
  }
  SEL_CHOICE.clear();
  refreshStartChoices(); render();
}
function onBaseChange(){
  const k=val('rootSel'), b=val('baseSel');
  const subSel=document.getElementById('subSel');
  if(k==="All Keys" || b==="All Base Modes"){ subSel.innerHTML=`<option>All Sub Modes</option>`; }
  else{
    const subs=uniqueSubsForBase(k,b);
    subSel.innerHTML = `<option>All Sub Modes</option>` + subs.map(s=>`<option value="${s.value}">${s.disp}</option>`).join("");
  }
  SEL_CHOICE.clear();
  refreshStartChoices(); render();
}
function refreshStartChoices(){
  const key=val('rootSel');
  const allowedKeys = key==="All Keys"? DB.keys : [key];
  const set=new Set();
  for(const K of allowedKeys){
    const bases=DB.data[K]||{};
    for(const [B,subs] of Object.entries(bases)){
      for(const [S,rows] of Object.entries(subs)){
        for(const row of rows) for(const ch of row.degrees) set.add(normLabel(ch));
      }
    }
  }
  const startSel=document.getElementById('startSel');
  startSel.innerHTML=['(none)',...Array.from(set).filter(Boolean).sort()].map(v=>`<option>${v}</option>`).join("");
}

/* ===== Families for a (root, base) in modal order ===== */
function familiesFor(rootKey, base){
  const baseName = (base || "Ionian").replace(/^[A-G](?:#|b)?\s+/, ""); // "C Ionian" -> "Ionian"
  const steps = MODE_STEPS[(baseName || "ionian").toLowerCase()] || MODE_STEPS.ionian;
  const R = noteToSemi[rootKey] ?? 0;
  return steps.map(d => `${CANON[(R + d + 1200) % 12]} ${baseName}`);
}

  /* === Key ordering helpers === */
function keySemitone(K){
  const k = (K||"").trim();
  if (noteToSemi.hasOwnProperty(k)) return noteToSemi[k];
  const t = k.replace(/[^A-G#b]/gi,"");
  return noteToSemi[t] ?? 0;
}
function sortKeysChromatic(arr, start='C'){
  const s = keySemitone(start);
  return arr.slice().sort((a,b)=>{
    const da = (keySemitone(a) - s + 12) % 12;
    const db = (keySemitone(b) - s + 12) % 12;
    return da - db;
  });
}

/* ===== Sampling ===== */
let CURRENT=[];
function bucketsFor(k,b,s){
  const keys=(k==="All Keys")? DB.keys : [k];
  const out=[];
  for(const K of keys){
    for(const [B,subs] of Object.entries(DB.data[K]||{})){
      if(b!=="All Base Modes" && B!==b) continue;
      for(const [S,rows] of Object.entries(subs)){
        if(s!=="All Sub Modes" && S!==s) continue;
        for(const row of rows){
          const degs=(row.degrees||[]).filter(Boolean);
          if(degs.length){ out.push({key:K,base:B,sub:S,family:row.family,row:degs}); }
        }
      }
    }
  }
  return out;
}
function sample(n){
  const k=val('rootSel'), b=val('baseSel'), s=val('subSel');
  const spicy=parseInt(val('spicy'))/100;
  const start=val('startSel'); const startOpt=(start && start!=="(none)")? start:null;

  const groups=bucketsFor(k,b,s);
  const pool=[]; 
  for(const g of groups){
    g.row.forEach((label,ci)=>{
      const lab = normLabel(label);
      pool.push({label:lab, key:g.key,base:g.base,sub:g.sub,family:g.family,ci});
    });
  }
  if(!pool.length) return [];

  for(let i=pool.length-1;i>0;i--){ const j=rand(i+1); [pool[i],pool[j]]=[pool[j],pool[i]]; }

  const out=[]; const used=new Set();
  function biasedPick(prev){
    if(!prev || spicy<=0) return pool.pop();
    const A=chordPCSet(prev.label);
    const k=Math.min(12,pool.length);
    const cand=pool.slice(-k).map((o,idx)=>({idx:pool.length-k+idx,o,sc:jaccard(A,chordPCSet(o.label))})).sort((x,y)=>y.sc-x.sc);
    const top=Math.max(1, Math.round(1+spicy*5));
    const choice=cand[rand(Math.min(top,cand.length))];
    return pool.splice(choice.idx,1)[0];
  }

  if(startOpt){
    const idx=pool.findIndex(o=>o.label===startOpt);
    const pre=(idx>=0)? pool.splice(idx,1)[0] : {label:startOpt,key:k,base:b,sub:s,family:"",ci:0};
    out.push(pre); used.add(pre.label);
  }
  while(out.length<n && pool.length){
    const p=biasedPick(out[out.length-1]);
    if(!el('noRepeat').checked || !used.has(p.label)){ out.push(p); used.add(p.label); }
  }
  return out;
}

/* ===== Cards & audio ===== */
let audioCtx=null; function ctx(){ if(!audioCtx) audioCtx=new (window.AudioContext||window.webkitAudioContext)(); return audioCtx; }
function playChord(notes,gain=0.45,seconds=0.9){
  const ac=ctx(); const now=ac.currentTime+0.01;
  const comp=ac.createDynamicsCompressor(); comp.threshold.value=-24; comp.knee.value=30; comp.ratio.value=12; comp.attack.value=0.003; comp.release.value=0.25;
  const master=ac.createGain(); const vol=Math.pow(Math.max(0,Math.min(1,gain)),1.6); master.gain.value=vol; comp.connect(master); master.connect(ac.destination);
  const base=60; const a=0.02,d=0.03,s=0.85,r=0.20; const end=now+seconds;
  for(const x of notes){
    const osc=ac.createOscillator(); const g=ac.createGain(); const hz=440*Math.pow(2,((base+(x%12))-69)/12);
    osc.type='sine'; osc.frequency.setValueAtTime(hz, now);
    g.gain.setValueAtTime(0.0001, now); g.gain.exponentialRampToValueAtTime(0.6/Math.sqrt(notes.length), now+a);
    g.gain.exponentialRampToValueAtTime(0.6/Math.sqrt(notes.length)*s, now+a+d);
    g.gain.setValueAtTime(0.6/Math.sqrt(notes.length)*s, end-r); g.gain.exponentialRampToValueAtTime(0.0001, end);
    osc.connect(g); g.connect(comp); osc.start(now); osc.stop(end+0.02);
  }
}
function drawKeys(notes, rootPC){
  const onset=new Set((notes||[]).map(n=>((n%12)+12)%12));
  const NS="http://www.w3.org/2000/svg", W=420,H=110;
  const svg=document.createElementNS(NS,"svg");
  svg.setAttribute("viewBox",`0 0 ${W} ${H}`);

  // Build a lightweight key map so we know where BOTH white and black keys are
  const keys=[]; // {midi, pc, isBlack, x, w}

  // --- Whites ---
  const whites=[]; let count=0, midi=48; // start at C3
  while(count<22){
    const pc = ((midi%12)+12)%12;
    if(![1,3,6,8,10].includes(pc)){ // not a black pitch class
      whites.push(midi);
      count++;
    }
    midi++;
  }
  const ww=W/22;

  whites.forEach((m,i)=>{
    const pc=((m%12)+12)%12;
    const x=i*ww;
    const r=document.createElementNS(NS,"rect");
    r.setAttribute("x",x); r.setAttribute("y",0);
    r.setAttribute("width",ww); r.setAttribute("height",H);
    r.setAttribute("fill", onset.has(pc) ? "#86efac" : "#ffffff");
    r.setAttribute("stroke","#222");
    svg.appendChild(r);
    keys.push({midi:m, pc, isBlack:false, x, w:ww});
  });

  // --- Blacks ---
  for(let n=48;n<48+36;n++){
    const pc=((n%12)+12)%12;
    if([1,3,6,8,10].includes(pc)){
      // place between its surrounding whites
      const wi = whites.findIndex(w=>w>n) - 1;
      if(wi>=0){
        const x = wi*ww + ww*0.65;
        const r=document.createElementNS(NS,"rect");
        r.setAttribute("x",x); r.setAttribute("y",0);
        r.setAttribute("width",ww*0.6); r.setAttribute("height",H*0.65);
        r.setAttribute("fill", onset.has(pc) ? "#86efac" : "#111");
        r.setAttribute("stroke","#222");
        r.setAttribute("rx","2"); r.setAttribute("ry","2");
        svg.appendChild(r);
        keys.push({midi:n, pc, isBlack:true, x, w:ww*0.6});
      }
    }
  }

  // --- Root dot (works for both white & black roots) ---
  const rpc = ((rootPC%12)+12)%12;
  const candidates = keys.filter(k => k.pc===rpc);
  if(candidates.length){
    // pick the visually most central instance of that pitch class
    const center = W/2;
    candidates.sort((a,b)=>Math.abs((a.x+a.w/2)-center) - Math.abs((b.x+b.w/2)-center));
    const k0 = candidates[0];
    const cx = k0.x + k0.w/2;
    const cy = k0.isBlack ? (H*0.22) : (H-8); // higher for black keys so it's visible
    const dot=document.createElementNS(NS,"circle");
    dot.setAttribute("cx",cx); dot.setAttribute("cy",cy);
    dot.setAttribute("r",5);
    dot.setAttribute("fill","#60a5fa");
    dot.setAttribute("stroke","#1e3a8a");
    dot.setAttribute("stroke-width","1.5");
    dot.setAttribute("pointer-events","none"); // keep tooltip/hover behavior sane
    svg.appendChild(dot);
  }

  return svg;
}

function renderCards(seq){
  CURRENT=seq.slice();
  SEL_CHOICE.clear();
  const cont=el('cards'); cont.innerHTML="";
  const vol=parseInt(val('vol'))/100;
  seq.forEach((o,i)=>{
    const [root,q]=parseLabel(o.label); const [notes,R]=build7th(root,q);
    const card=document.createElement('div'); card.className="card";
    const meta=document.createElement('div'); meta.style.flex="0 0 160px"; meta.innerHTML=`<h3>#${i+1}</h3><div>${o.label}</div><div class="small">${o.key} ‚Ä¢ ${o.base} ‚Ä¢ ${displaySubLabel(o.sub)}${o.family?(' ‚Ä¢ '+o.family):''}</div>`;
    const img=document.createElement('div'); img.style.flex="1"; img.appendChild(drawKeys(notes, R%12));
    const btns=document.createElement('div'); btns.style.display="flex"; btns.style.flexDirection="column"; btns.style.gap="8px"; btns.style.width="120px";
    const play=document.createElement('button'); play.textContent="‚ñ∂Ô∏è Play"; play.onclick=()=>{ ctx().resume(); playChord(notes,vol); pulseByLabel(o.label); };
    btns.append(play);
    card.append(meta,img,btns); cont.append(card);
  });
  showSelectionOverlay(); drawSelectionPath();
}

/* ===== SVG / Rendering ===== */
const svg=el('sun'), gZoom=el('zoomG'), gModes=el('modesG'), gChart=el('chartG'), gSel=el('selG'), gPath=el('pathG'), gPulse=el('pulseG');
const W=1200,H=860,CX=W/2,CY=H/2;
function mk(tag,attr){ const e=document.createElementNS('http://www.w3.org/2000/svg',tag); for(const [k,v] of Object.entries(attr||{})) e.setAttribute(k,v); return e; }
function polar(r,a){ const rad=a*Math.PI/180; return [CX + r*Math.cos(rad), CY + r*Math.sin(rad)]; }
const baseCols=["#22c55e","#10b981","#06b6d4","#3b82f6","#6366f1","#a855f7","#ef4444"];
function colorFor(B,S,ri){ if(ri!=null) return ["#7dd3fc","#93c5fd","#a7f3d0","#fde68a","#fca5a5","#c7d2fe","#99f6e4","#fecaca"][ri%8]; return baseCols[Math.max(0,modeRank(B))%baseCols.length]; }

/* ===== CHG: Sub-family palette & helpers (for All Sub Modes coloring) ===== */
const subCols = ["#ef4444","#f59e0b","#84cc16","#10b981","#06b6d4","#3b82f6","#a855f7"];
function subFamilyIndex(S){
  const disp = displaySubLabel(S||"");
  const head = (disp.split(/\s+/)[0]||"").toLowerCase();
  const i = MODE_ORDER.findIndex(m => m.toLowerCase()===head);
  return i>=0 ? i : 0;
}
function subFamilyColor(S){ return subCols[subFamilyIndex(S) % subCols.length]; }
/* ===== end CHG ===== */

function node(title,x,y,r,fill){
  const d=mk('circle',{cx:x,cy:y,r:r,fill:fill||"#93c5fd",stroke:"#0b1220","stroke-width":2,opacity:.98,class:"n","data-tip":title});
  return d;
}

/* ===== Stable selection endpoints ===== */
let SEL_POS=new Map();     
let SEL_CHOICE=new Map();  
function showSelectionOverlay(){
  SEL_POS=new Map();
  while(gSel.firstChild) gSel.removeChild(gSel.firstChild);
  const seq=CURRENT; if(!seq||!seq.length) return;

  seq.forEach((o,i)=>{
    const keyLab = normLabel(o.label);
    const plist=DB.nodeIndex.get(keyLab)||[];
    if(!plist.length) return;
    let idx = SEL_CHOICE.has(keyLab) ? SEL_CHOICE.get(keyLab) : rand(plist.length);
    if(idx>=plist.length) idx = plist.length-1;
    SEL_CHOICE.set(keyLab, idx);
    const p = plist[idx];
    SEL_POS.set(keyLab,p);

    const dot=mk('circle',{cx:p.x,cy:p.y,r:8,fill:"#fff",stroke:"#0b1220","stroke-width":2,class:"n","data-tip":`#${i+1} ‚Ä¢ ${o.label}`});
    const num=mk('text',{x:p.x,y:p.y+4,'text-anchor':'middle',style:"font:700 11px system-ui; fill:#000; paint-order:stroke; stroke:#fff; stroke-width:2.5px"}); num.textContent=(i<9)?(i+1):'‚Ä¢';
    dot.addEventListener('click',()=>pulseAt(p.x,p.y));
    num.addEventListener('click',()=>pulseAt(p.x,p.y));
    gSel.appendChild(dot); gSel.appendChild(num);
  });
}
function drawSelectionPath(){
  while(gPath.firstChild) gPath.removeChild(gPath.firstChild);
  const seq=CURRENT; if(!seq||seq.length<2) return;
  const pts=seq.map(o=>{ const e=SEL_POS.get(normLabel(o.label)); return e? `${e.x},${e.y}`: null; }).filter(Boolean).join(' ');
  if(!pts) return;
  const glow=mk('polyline',{points:pts,fill:'none',stroke:'rgba(34,211,238,.35)',"stroke-width":9,"stroke-linecap":"round","stroke-linejoin":"round"});
  const line=mk('polyline',{points:pts,fill:'none',stroke:'rgba(34,211,238,.9)',"stroke-width":3,"stroke-linecap":"round","stroke-linejoin":"round"});
  gPath.appendChild(glow); gPath.appendChild(line);
}
function pulseAt(x,y){
  const ring=mk('circle',{cx:x,cy:y,r:9,fill:'none',stroke:'#22d3ee','stroke-width':3,opacity:.95});
  gPulse.appendChild(ring);
  let r=9,op=.95,c=0; (function tick(){ c++; r+=1.8; op*=.92; ring.setAttribute('r',r); ring.setAttribute('opacity',op); if(c<18) requestAnimationFrame(tick); else gPulse.removeChild(ring); })();
}
function pulseByLabel(label){
  const e=SEL_POS.get(normLabel(label)) || (DB.nodeIndex.get(normLabel(label))||[])[0]; if(e) pulseAt(e.x,e.y);
}

/* ===== NEW helper: degrees for a family (any sub of a base) ===== */
function degreesForFamilyAnySub(K,B,fam){
  const subs = ((DB.data[K]||{})[B]||{});
  for(const [S,rows] of Object.entries(subs)){
    const hit = rows.find(r => normLabel(r.family)===normLabel(fam));
    if(hit && Array.isArray(hit.degrees) && hit.degrees.length){
      return {degrees: hit.degrees.map(normLabel), sub:S};
    }
  }
  const entries = Object.entries(subs);
  if(entries.length && entries[0][1].length && entries[0][1][0].degrees?.length){
    return {degrees: entries[0][1][0].degrees.map(normLabel), sub: entries[0][0]};
  }
  return {degrees: [], sub: ""};
}


/* ===== Main render ===== */
function render(){
  [gModes,gChart,gSel,gPath,gPulse].forEach(g=>{ while(g.firstChild) g.removeChild(g.firstChild); });
  DB.nodeIndex.clear();

  const k=val('rootSel'), b=val('baseSel'), s=val('subSel');
  const nodeR=parseInt(val('nodeR')), gap=parseInt(val('rowGap'));
  const mini = el('mini').checked, miniBy = el('miniGroup').value;
  const miniSpace = parseInt(val('miniSpace'));

  /* ===== CHG: when Sub = All Sub Modes, color by sub-family ===== */
  const useSubColors = (s === "All Sub Modes");
  /* ===== end CHG ===== */

  const ring0=110, ringSub=ring0+64, ringFam=ringSub+36;
  const a0=-90;

  const scenario = (k!=="All Keys" && b!=="All Base Modes" && s!=="All Sub Modes") ? 1 :
                   (k!=="All Keys" && b!=="All Base Modes" && s==="All Sub Modes") ? 2 :
                   (k!=="All Keys" && b==="All Base Modes" && s==="All Sub Modes") ? 3 : 0;

let centerLabel = "All Keys";
if(scenario===1) centerLabel = displaySubLabel(s);
else if(scenario===2) centerLabel = `${k} ${b.replace(/^[A-G](?:#|b)?\s+/,"")}`;
else if(scenario===3) centerLabel = k;
gModes.appendChild(node(centerLabel, CX, CY, 16, "#fff"));

if(scenario===1){
  // Specific sub mode
  const famOrder=familiesFor(k,b);
  const rows = (((DB.data[k]||{})[b]||{})[s]||[]);
  const famMap=new Map(); rows.forEach(r=>{ if(r.family) famMap.set(normLabel(r.family), r.degrees.map(normLabel)); });
  const step=360/7;
  { const [sx,sy]=polar(ringSub,a0); gModes.appendChild(node(displaySubLabel(s), sx,sy,7, "#93c5fd")); }
  for(let i=0;i<7;i++){
    const a=a0 + i*step;
    const fam=famOrder[i];
    const [fx,fy]=polar(ringFam,a);
    gModes.appendChild(node(fam, fx,fy,7, baseCols[i%7]));
    const degs=famMap.get(normLabel(fam)) || (rows[0]?.degrees||[]).map(normLabel);
    for(let di=0; di<Math.min(7,degs.length); di++){
      const [x,y]=polar(ringFam+30+di*gap, a);
      const lab=normLabel(degs[di]);
      const d=node(lab,x,y,nodeR, colorFor(b,s,di));
      gChart.appendChild(d);
      (DB.nodeIndex.get(lab) || DB.nodeIndex.set(lab,[]), DB.nodeIndex.get(lab)).push({x,y});
    }
  }

  // --- NEW: endpoints for all selected chords (even if degree index > 7) ---
  // Build label -> {fi (family index 0..6), di (degree index)} for this submode
  const LIDX = new Map();
  rows.forEach(r=>{
    const famName = normLabel(r.family||"");
    const fiRaw = famOrder.findIndex(f => normLabel(f) === famName);
    const fi = fiRaw >= 0 ? fiRaw : 0;
    (r.degrees||[]).forEach((d,di)=>{
      LIDX.set(normLabel(d), { fi, di });
    });
  });

  (CURRENT||[]).forEach(o=>{
    const lab = normLabel(o.label);
    if(!DB.nodeIndex.has(lab) && LIDX.has(lab)){
      const { fi, di } = LIDX.get(lab);
      const a  = a0 + fi*step;
      const rr = ringFam + 30 + di*gap; // true ring position for this degree index
      const [x,y] = polar(rr, a);
      const d = node(lab, x, y, nodeR, colorFor(b, s, di));
      gChart.appendChild(d);
      (DB.nodeIndex.get(lab) || DB.nodeIndex.set(lab,[]), DB.nodeIndex.get(lab)).push({x,y});
    }
  });
  // --- END NEW ---
}

  else if(scenario===2){
    // Specific base (All Subs)
    const subsUnique = uniqueSubsForBase(k,b); // de-dup display
    if(mini && miniBy==='sub'){
      // *** Mini clusters grouped by SUB ***
      const step=360/Math.max(1,subsUnique.length);
      const ringCluster = 200 + miniSpace * 1.4; // spread control
      subsUnique.forEach((obj,si)=>{
        const S=obj.value, Slabel=obj.disp;
        const a=a0+si*step; const [cx,cy]=polar(ringCluster,a);
        // center label: the Sub once (no spam)
        gModes.appendChild(node(Slabel, cx, cy, 7.2, useSubColors ? subFamilyColor(S) : "#a78bfa")); // CHG

        const rows = (((DB.data[k]||{})[b]||{})[S]||[]);
        const famOrder=familiesFor(k,b);
        const famMap=new Map(); rows.forEach(r=>{ if(r.family) famMap.set(normLabel(r.family), r.degrees.map(normLabel)); });

        // families around sub center
        for(let fi=0; fi<7; fi++){
          const aa = (a-90) + fi*(360/Math.max(7,7));
          const [fx,fy]=[ cx + Math.cos(aa*Math.PI/180)*74, cy + Math.sin(aa*Math.PI/180)*74 ];
          gModes.appendChild(node(famOrder[fi], fx,fy,6, baseCols[fi%7]));
          const degs=famMap.get(normLabel(famOrder[fi])) || (rows[fi]?.degrees||rows[0]?.degrees||[]).map(normLabel);
          for(let di=0; di<Math.min(7,degs.length); di++){
            const rr = 74 + 20 + di*(gap*0.75);
            const [x,y]=[ cx + Math.cos(aa*Math.PI/180)*rr, cy + Math.sin(aa*Math.PI/180)*rr ];
            const lab=normLabel(degs[di]);
            const d=node(lab,x,y,nodeR, useSubColors ? subFamilyColor(S) : colorFor(b,S,di)); // CHG
            gChart.appendChild(d);
            (DB.nodeIndex.get(lab) || DB.nodeIndex.set(lab,[]), DB.nodeIndex.get(lab)).push({x,y});
          }
        }
      });
    } else {
      // Radial (non-mini) ‚Äî still uses unique sub labels, no duplication
      const total=7*subsUnique.length; const step=360/Math.max(1,total);
      let si=0;
      subsUnique.forEach(({value:S, disp})=>{
        const rows = (((DB.data[k]||{})[b]||{})[S]||[]);
        const famOrder=familiesFor(k,b);
        const famMap=new Map(); rows.forEach(r=>{ if(r.family) famMap.set(normLabel(r.family), r.degrees.map(normLabel)); });
        for(let fi=0; fi<7; fi++){
          const a=a0 + (si*step);
          const [sx,sy]=polar(ring0, a);
          gModes.appendChild(node(disp, sx,sy,4.8, useSubColors ? subFamilyColor(S) : "#a78bfa")); // CHG
          const fam=famOrder[fi];
          const [fx,fy]=polar(ring0+28, a);
          gModes.appendChild(node(fam, fx,fy,6.2, baseCols[fi%7]));
          const degs=famMap.get(normLabel(fam)) || (rows[fi]?.degrees||rows[0]?.degrees||[]).map(normLabel);
          for(let di=0; di<Math.min(7,degs.length); di++){
            const [x,y]=polar(ring0+28+26+di*gap, a);
            const lab=normLabel(degs[di]);
            const d=node(lab,x,y,nodeR, useSubColors ? subFamilyColor(S) : colorFor(b,S,di)); // CHG
            gChart.appendChild(d);
            (DB.nodeIndex.get(lab) || DB.nodeIndex.set(lab,[]), DB.nodeIndex.get(lab)).push({x,y});
          }
          si++;
        }
      });
    }
  }
  else if(scenario===3){
    // All base + All sub (one key) ‚Äî MINI clusters by BASE, spaced with slider
    const bases = Object.keys(DB.data[k]||{}).sort(sortModesCW);
    const step=360/Math.max(1,bases.length);
    const ringCluster=200 + miniSpace * 1.4; // spacing control

    if(mini){
      bases.forEach((B,bi)=>{
        const a=a0+bi*step; const [cx,cy]=polar(ringCluster,a);
        // center label: the Base once
        gModes.appendChild(node(`${k} ${B.replace(/^[A-G](?:#|b)?\s+/,"")}`, cx, cy, 7.5, "#22c55e"));

        // de-dup sub labels within this base
        const subsU = uniqueSubsForBase(k,B);
        const st=360/Math.max(1,7*subsU.length);
        let blockStart = 0;
        subsU.forEach(({value:S, disp})=>{
          // one sub label per sub (centered in its 7-slice block)
          const aSub = (a-90) + (blockStart+3.5)*st;
          const [sx,sy]=[ cx + Math.cos(aSub*Math.PI/180)*56, cy + Math.sin(aSub*Math.PI/180)*56 ];
          gModes.appendChild(node(disp, sx,sy,4.2, useSubColors ? subFamilyColor(S) : "#a78bfa")); // CHG

          const rows = (((DB.data[k]||{})[B]||{})[S]||[]);
          const famOrder=familiesFor(k,B);
          const famMap=new Map(); rows.forEach(r=>{ if(r.family) famMap.set(normLabel(r.family), r.degrees.map(normLabel)); });

          for(let fi=0; fi<7; fi++){
            const aa = (a-90) + (blockStart+fi)*st;
            const [fx,fy]=[ cx + Math.cos(aa*Math.PI/180)*84, cy + Math.sin(aa*Math.PI/180)*84 ];
            gModes.appendChild(node(famOrder[fi], fx,fy,6, baseCols[fi%7]));
            const degs=famMap.get(normLabel(famOrder[fi])) || (rows[fi]?.degrees||rows[0]?.degrees||[]).map(normLabel);
            for(let di=0; di<Math.min(7,degs.length); di++){
              const rr = 84 + 22 + di*(gap*0.75);
              const [x,y]=[ cx + Math.cos(aa*Math.PI/180)*rr, cy + Math.sin(aa*Math.PI/180)*rr ];
              const lab=normLabel(degs[di]);
              const d=node(lab,x,y,nodeR, useSubColors ? subFamilyColor(S) : colorFor(B,S,di)); // CHG
              gChart.appendChild(d);
              (DB.nodeIndex.get(lab) || DB.nodeIndex.set(lab,[]), DB.nodeIndex.get(lab)).push({x,y});
            }
          }
          blockStart += 7;
        });
      });
    } else {
      // Non-mini fallback scatter
      const groups=[];
      for(const [B,subs] of Object.entries(DB.data[k]||{})){
        for(const [S,rows] of Object.entries(subs)) groups.push({B,S,rows});
      }
      const step2=360/Math.max(1,groups.length);
      groups.forEach((G,gi)=>{
        const a=a0+gi*step2;
        for(let r=0; r<G.rows.length; r++){
          const row=G.rows[r];
          for(let di=0; di<Math.min(7,row.degrees.length); di++){
            const [x,y]=polar(130 + r*10 + di*gap, a);
            const lab=normLabel(row.degrees[di]);
            const d=node(lab,x,y,nodeR, useSubColors ? subFamilyColor(G.S) : colorFor(G.B,G.S,di)); // CHG
            gChart.appendChild(d);
            (DB.nodeIndex.get(lab) || DB.nodeIndex.set(lab,[]), DB.nodeIndex.get(lab)).push({x,y});
          }
        }
      });
    }
  } else if (k==="All Keys" && b==="All Base Modes" && s==="All Sub Modes" && mini) {
    // === NEW: All ROOTS mini webs (3-tier clusters per key) ===
    const keys = sortKeysChromatic(DB.keys, 'C'); // C, Db, D, Eb... clockwise
    const step = 360/Math.max(1, keys.length);
    const ringCluster = 220 + parseInt(val('miniSpace')) * 1.3; // how far clusters are from center

    keys.forEach((K,ki)=>{
      const a = a0 + ki*step;
      const [cx,cy] = polar(ringCluster, a);

      // Center of the mini web: the KEY (root)
      gModes.appendChild(node(K, cx, cy, 8, "#fff"));

      // Ring 1: bases around the key (Ionian..Locrian)
      const bases = Object.keys(DB.data[K]||{}).sort(sortModesCW);
      const stepBase = 360/Math.max(1, bases.length);
      const r1 = 62;           // radius for bases
      const r2 = r1 + 26;      // radius for families (ring 2)

      bases.forEach((B,bi)=>{
        const aa = (a-90) + bi*stepBase;

        // Base node (compact)
        const [bx,by] = [ cx + Math.cos(aa*Math.PI/180)*r1, cy + Math.sin(aa*Math.PI/180)*r1 ];
        gModes.appendChild(node(B.replace(/^[A-G](?:#|b)?\s+/,""), bx, by, 5.8, baseCols[bi%7]));

        // Ring 2: 7 mode families for this base, distributed between the base angles
        const famOrder = familiesFor(K, B);
        for(let fi=0; fi<7; fi++){
          const aa2 = aa + (fi*(stepBase/7)); // sub-step inside the base sector
          const [fx,fy] = [ cx + Math.cos(aa2*Math.PI/180)*r2, cy + Math.sin(aa2*Math.PI/180)*r2 ];
          gModes.appendChild(node(famOrder[fi], fx, fy, 4.4, baseCols[fi%7]));

          // Ring 3: a few chord degrees for that family (kept small for readability)
          const {degrees, sub} = degreesForFamilyAnySub(K, B, famOrder[fi]);
          //const take = Math.min(3, degrees.length);            // show up to 3 to keep it tidy
          const gap = parseInt(val('rowGap'));                 // reuse your existing slider
          const nodeR = parseInt(val('nodeR'));

          for(let di = 0; di < degrees.length; di++) {
            const rr = r2 + 18 + di*(gap*0.65);
            const xx = cx + Math.cos(aa2*Math.PI/180)*rr;
            const yy = cy + Math.sin(aa2*Math.PI/180)*rr;
            const lab = normLabel(degrees[di]);
            const d = node(lab, xx, yy, nodeR, sub ? subFamilyColor(sub) : colorFor(B, sub, di));
            gChart.appendChild(d);
            (DB.nodeIndex.get(lab) || DB.nodeIndex.set(lab,[]), DB.nodeIndex.get(lab)).push({x:xx,y:yy});
          }
        }
      });
    });

  } else {
    // Mixed/fallback (All Keys or other combos) ‚Äî keep your original scatter
    const keysOrdered = (k==="All Keys") ? sortKeysChromatic(DB.keys, 'C') : [k];
    const groups=[];
    for (const K of keysOrdered){
      for (const [B,subs] of Object.entries(DB.data[K]||{})){
        for (const [S,rows] of Object.entries(subs)) groups.push({K,B,S,rows});
      }
    }
    const step=360/Math.max(1,groups.length);
    groups.forEach((G,gi)=>{
      const a=a0+gi*step;
      for(let r=0; r<G.rows.length; r++){
        const row=G.rows[r];
        for(let di=0; di<Math.min(7,row.degrees.length); di++){
          const [x,y]=polar(130 + r*10 + di*gap, a);
          const lab=normLabel(row.degrees[di]);
          const d=node(lab,x,y,parseInt(val('nodeR')), useSubColors ? subFamilyColor(G.S) : colorFor(G.B,G.S,di));
          gChart.appendChild(d);
          (DB.nodeIndex.get(lab) || DB.nodeIndex.set(lab,[]), DB.nodeIndex.get(lab)).push({x,y});
        }
      }
    });
  }


  el('vizMeta').textContent = `${k} ‚Ä¢ ${b} ‚Ä¢ ${s}`;
  showSelectionOverlay(); drawSelectionPath();
}

/* ===== Misc UI ===== */
function el(id){return document.getElementById(id)}
function val(id){return el(id).value}

el('openSettings').onclick=()=>{ el('settings').style.display='flex'; };
el('closeSettings').onclick=()=>{ el('settings').style.display='none'; };

el('themeBtn').onclick=()=>{ const root=document.documentElement; const light=root.getAttribute('data-theme')==='light'; root.setAttribute('data-theme', light?'dark':'light'); el('themeBtn').textContent = light ? 'üåô' : '‚òÄÔ∏è'; };

el('rootSel').onchange = onRootChange;
el('baseSel').onchange = onBaseChange;
el('subSel').onchange  = ()=>{ SEL_CHOICE.clear(); refreshStartChoices(); render(); };
['nodeR','rowGap','mini','miniSpace','miniGroup'].forEach(id => { el(id).oninput=render; el(id).onchange=render; });

el('gen').onclick=()=>{ const n=Math.max(1,Math.min(16,parseInt(val('count')||"4"))); const seq=sample(n); el('notice').textContent=seq.length? "":"No chords for this selection."; renderCards(seq); };
el('copy').onclick=async()=>{ const txt=CURRENT.map(x=>x.label).join(', '); try{ await navigator.clipboard.writeText(txt); el('notice').textContent="Copied."; setTimeout(()=>el('notice').textContent="",1000);}catch(e){ el('notice').textContent="Copy failed."; } };
el('resetAll').onclick=()=>{ el('count').value=4; el('vol').value=45; el('spicy').value=0; el('noRepeat').checked=true; el('mini').checked=true; el('miniSpace').value=80; el('miniGroup').value='base'; el('rootSel').value='All Keys'; el('baseSel').innerHTML=`<option>All Base Modes</option>`; el('subSel').innerHTML=`<option>All Sub Modes</option>`; scale=1; tx=0; ty=0; applyZoom(); SEL_CHOICE.clear(); render(); el('cards').innerHTML=""; CURRENT=[]; };

/* Random picks */
el('rootRnd').onclick=()=>{ if(!DB.keys.length) return; el('rootSel').value=DB.keys[rand(DB.keys.length)]; onRootChange(); };
el('baseRnd').onclick=()=>{ const k=val('rootSel'); if(k==="All Keys") return; const bases=Object.keys(DB.data[k]||{}).sort(sortModesCW); if(!bases.length) return; el('baseSel').value=bases[rand(bases.length)]; onBaseChange(); };
el('subRnd').onclick=()=>{ const k=val('rootSel'), b=val('baseSel'); if(k==="All Keys"||b==="All Base Modes") return; const subs=uniqueSubsForBase(k,b); if(!subs.length) return; el('subSel').value=subs[rand(subs.length)].value; SEL_CHOICE.clear(); render(); };

/* Hotkeys: 1..8 play items #1..#8; G generate; R reset */
window.addEventListener('keydown',(e)=>{
  const tag=(e.target&&e.target.tagName||'').toLowerCase();
  if(tag==='input' || tag==='select' || tag==='textarea') return;
  const k=e.key;
  if(k>='1' && k<='8'){ const idx=parseInt(k,10)-1; const o=CURRENT[idx]; if(o){ const [root,q]=parseLabel(o.label); const [notes]=build7th(root,q); ctx().resume(); playChord(notes, parseInt(val('vol'))/100); pulseByLabel(o.label); e.preventDefault(); } }
  if(k.toLowerCase()==='g'){ e.preventDefault(); el('gen').click(); }
  if(k.toLowerCase()==='r'){ e.preventDefault(); el('resetAll').click(); }
});

/* Tooltips ‚Äî ONLY for nodes with class 'n' */
const tip=el('tip');
function setTip(txt,x,y){ tip.textContent=txt; tip.style.left=(x+10)+'px'; tip.style.top=(y+10)+'px'; tip.style.opacity=1; }
function hideTip(){ tip.style.opacity=0; }
svg.addEventListener('mousemove',(e)=>{
  const t=e.target;
  if(t && t.classList && t.classList.contains('n')){
    const txt=t.getAttribute('data-tip')||'';
    if(txt){ setTip(txt,e.clientX,e.clientY); return; }
  }
  hideTip();
});
svg.addEventListener('mouseleave', hideTip);

/* Pan + NO scroll-wheel zoom (blocked) */
let scale=1, tx=0, ty=0, panning=false, start={x:0,y:0};
function applyZoom(){ gZoom.setAttribute('transform',`translate(${tx},${ty}) scale(${scale})`); }
svg.addEventListener('wheel', (e)=>{ e.preventDefault(); }, {passive:false});
svg.addEventListener('mousedown',(e)=>{ panning=true; start={x:e.clientX,y:e.clientY}; });
window.addEventListener('mouseup',()=>{ panning=false; });
window.addEventListener('mousemove',(e)=>{ if(!panning) return; const dx=e.clientX-start.x, dy=e.clientY-start.y; tx+=dx; ty+=dy; start={x:e.clientX,y:e.clientY}; applyZoom(); });
el('zoomIn').onclick = ()=>{ const s2=Math.min(10,scale*1.2); tx=CX-(CX-tx)*(s2/scale); ty=CY-(CY-ty)*(s2/scale); scale=s2; applyZoom(); };
el('zoomOut').onclick= ()=>{ const s2=Math.max(0.05,scale/1.2); tx=CX-(CX-tx)*(s2/scale); ty=CY-(CY-ty)*(s2/scale); scale=s2; applyZoom(); };
el('zoomReset').onclick=()=>{ scale=1; tx=0; ty=0; applyZoom(); };
el('redraw').onclick=render;

/* Loaders + autoload */
async function loadFromArrayBuffer(ab){
  try{
    const wb=XLSX.read(ab,{type:"array"}); ingestXLSX(wb); updateSelectors(); render();
    el('parseStats').innerHTML = `Sheets: ${DB.stats.sheets}<br>Rows: ${DB.stats.rows}<br>Rows used: ${DB.stats.rowsUsed}<br>Chord cells: ${DB.stats.chordCells}`;
    setInitialDefaults();
  }catch(e){ el('parseStats').textContent='Load failed: '+e.message; console.error(e); }
}
function setInitialDefaults(){
  const rootSel=el('rootSel'); if([...rootSel.options].some(o=>o.value==='C')){ rootSel.value='C'; onRootChange(); } else { onRootChange(); }
  const baseSel=el('baseSel'); const ionBase=[...baseSel.options].find(o=>/ionian/i.test(o.value)); if(ionBase){ baseSel.value=ionBase.value; onBaseChange(); }
  const subSel=el('subSel'); const ionSub=[...subSel.options].find(o=>/ionian\s+ionians/i.test(o.textContent)); if(ionSub){ subSel.value=ionSub.value; render(); }
}
el('file').addEventListener('change', async (ev)=>{ const f=ev.target.files?.[0]; if(!f) return; const ab=await f.arrayBuffer(); await loadFromArrayBuffer(ab); });
el('dataURLLoad').onclick = async ()=>{
  const url=val('dataURL').trim(); if(!url){ el('parseStats').textContent='Enter a URL'; return; }
  try{ el('parseStats').textContent='Loading‚Ä¶'; const res=await fetch(url,{cache:'no-store'}); if(!res.ok) throw new Error('HTTP '+res.status); const ab=await res.arrayBuffer(); await loadFromArrayBuffer(ab); el('settings').style.display='none'; }
  catch(e){ el('parseStats').innerHTML=`Load failed: ${e.message}<br>Tip: CORS can block remote files ‚Äî try another host or the file upload.`; }
};
/* Autoload: ?xlsx=‚Ä¶ override, else use your GitHub URL by default */
(function(){
  const p=new URLSearchParams(location.search);
  const url = p.get('xlsx') || 'https://santismo.github.io/ChordWeb/data.xlsx';
  el('dataURL').value = url;
  (async()=>{ try{ el('parseStats').textContent='Loading‚Ä¶'; const r=await fetch(url,{cache:'no-store'}); if(!r.ok) throw new Error('HTTP '+r.status); const ab=await r.arrayBuffer(); await loadFromArrayBuffer(ab); } catch(e){ el('parseStats').innerHTML=`Auto-load failed: ${e.message}<br>Open ‚öôÔ∏è Settings to load manually.`; }})();
})();
</script>
</body>
</html>
